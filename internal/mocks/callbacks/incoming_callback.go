// Code generated by MockGen. DO NOT EDIT.
// Source: internal/model/callbacks/incoming_callback.go

// Package mock_callbacks is a generated GoMock package.
package mock_callbacks

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	decimal "github.com/shopspring/decimal"
	model "gitlab.ozon.dev/dmitryssaenko/financial-tg-bot/internal/model"
)

// MockUserStore is a mock of UserStore interface.
type MockUserStore struct {
	ctrl     *gomock.Controller
	recorder *MockUserStoreMockRecorder
}

// MockUserStoreMockRecorder is the mock recorder for MockUserStore.
type MockUserStoreMockRecorder struct {
	mock *MockUserStore
}

// NewMockUserStore creates a new mock instance.
func NewMockUserStore(ctrl *gomock.Controller) *MockUserStore {
	mock := &MockUserStore{ctrl: ctrl}
	mock.recorder = &MockUserStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserStore) EXPECT() *MockUserStoreMockRecorder {
	return m.recorder
}

// GetUserCurrency mocks base method.
func (m *MockUserStore) GetUserCurrency(ctx context.Context, userID int64) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUserCurrency", ctx, userID)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUserCurrency indicates an expected call of GetUserCurrency.
func (mr *MockUserStoreMockRecorder) GetUserCurrency(ctx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserCurrency", reflect.TypeOf((*MockUserStore)(nil).GetUserCurrency), ctx, userID)
}

// SetUserCurrency mocks base method.
func (m *MockUserStore) SetUserCurrency(ctx context.Context, userID int64, newCurrency string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUserCurrency", ctx, userID, newCurrency)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetUserCurrency indicates an expected call of SetUserCurrency.
func (mr *MockUserStoreMockRecorder) SetUserCurrency(ctx, userID, newCurrency interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUserCurrency", reflect.TypeOf((*MockUserStore)(nil).SetUserCurrency), ctx, userID, newCurrency)
}

// MockCategoryStore is a mock of CategoryStore interface.
type MockCategoryStore struct {
	ctrl     *gomock.Controller
	recorder *MockCategoryStoreMockRecorder
}

// MockCategoryStoreMockRecorder is the mock recorder for MockCategoryStore.
type MockCategoryStoreMockRecorder struct {
	mock *MockCategoryStore
}

// NewMockCategoryStore creates a new mock instance.
func NewMockCategoryStore(ctrl *gomock.Controller) *MockCategoryStore {
	mock := &MockCategoryStore{ctrl: ctrl}
	mock.recorder = &MockCategoryStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCategoryStore) EXPECT() *MockCategoryStoreMockRecorder {
	return m.recorder
}

// ResolveCategories mocks base method.
func (m *MockCategoryStore) ResolveCategories(ctx context.Context, IDs []string) (map[string]model.CategoryData, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveCategories", ctx, IDs)
	ret0, _ := ret[0].(map[string]model.CategoryData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveCategories indicates an expected call of ResolveCategories.
func (mr *MockCategoryStoreMockRecorder) ResolveCategories(ctx, IDs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveCategories", reflect.TypeOf((*MockCategoryStore)(nil).ResolveCategories), ctx, IDs)
}

// MockTransactionStore is a mock of TransactionStore interface.
type MockTransactionStore struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionStoreMockRecorder
}

// MockTransactionStoreMockRecorder is the mock recorder for MockTransactionStore.
type MockTransactionStoreMockRecorder struct {
	mock *MockTransactionStore
}

// NewMockTransactionStore creates a new mock instance.
func NewMockTransactionStore(ctrl *gomock.Controller) *MockTransactionStore {
	mock := &MockTransactionStore{ctrl: ctrl}
	mock.recorder = &MockTransactionStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransactionStore) EXPECT() *MockTransactionStoreMockRecorder {
	return m.recorder
}

// AddOperation mocks base method.
func (m *MockTransactionStore) AddOperation(ctx context.Context, userID int64, categoryID string, amount decimal.Decimal, createdAt time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddOperation", ctx, userID, categoryID, amount, createdAt)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddOperation indicates an expected call of AddOperation.
func (mr *MockTransactionStoreMockRecorder) AddOperation(ctx, userID, categoryID, amount, createdAt interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddOperation", reflect.TypeOf((*MockTransactionStore)(nil).AddOperation), ctx, userID, categoryID, amount, createdAt)
}

// MockLimitationRepo is a mock of LimitationRepo interface.
type MockLimitationRepo struct {
	ctrl     *gomock.Controller
	recorder *MockLimitationRepoMockRecorder
}

// MockLimitationRepoMockRecorder is the mock recorder for MockLimitationRepo.
type MockLimitationRepoMockRecorder struct {
	mock *MockLimitationRepo
}

// NewMockLimitationRepo creates a new mock instance.
func NewMockLimitationRepo(ctrl *gomock.Controller) *MockLimitationRepo {
	mock := &MockLimitationRepo{ctrl: ctrl}
	mock.recorder = &MockLimitationRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLimitationRepo) EXPECT() *MockLimitationRepoMockRecorder {
	return m.recorder
}

// AddLimit mocks base method.
func (m *MockLimitationRepo) AddLimit(ctx context.Context, userID int64, categoryID string, upperBorder decimal.Decimal, untilDate time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddLimit", ctx, userID, categoryID, upperBorder, untilDate)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddLimit indicates an expected call of AddLimit.
func (mr *MockLimitationRepoMockRecorder) AddLimit(ctx, userID, categoryID, upperBorder, untilDate interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddLimit", reflect.TypeOf((*MockLimitationRepo)(nil).AddLimit), ctx, userID, categoryID, upperBorder, untilDate)
}

// CheckLimit mocks base method.
func (m *MockLimitationRepo) CheckLimit(ctx context.Context, userID int64, categoryID string, amount decimal.Decimal) (decimal.Decimal, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckLimit", ctx, userID, categoryID, amount)
	ret0, _ := ret[0].(decimal.Decimal)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CheckLimit indicates an expected call of CheckLimit.
func (mr *MockLimitationRepoMockRecorder) CheckLimit(ctx, userID, categoryID, amount interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckLimit", reflect.TypeOf((*MockLimitationRepo)(nil).CheckLimit), ctx, userID, categoryID, amount)
}

// MockCurrencyExchanger is a mock of CurrencyExchanger interface.
type MockCurrencyExchanger struct {
	ctrl     *gomock.Controller
	recorder *MockCurrencyExchangerMockRecorder
}

// MockCurrencyExchangerMockRecorder is the mock recorder for MockCurrencyExchanger.
type MockCurrencyExchangerMockRecorder struct {
	mock *MockCurrencyExchanger
}

// NewMockCurrencyExchanger creates a new mock instance.
func NewMockCurrencyExchanger(ctrl *gomock.Controller) *MockCurrencyExchanger {
	mock := &MockCurrencyExchanger{ctrl: ctrl}
	mock.recorder = &MockCurrencyExchangerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCurrencyExchanger) EXPECT() *MockCurrencyExchangerMockRecorder {
	return m.recorder
}

// GetMultiplier mocks base method.
func (m *MockCurrencyExchanger) GetMultiplier(ctx context.Context, currency string, date time.Time) (decimal.Decimal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMultiplier", ctx, currency, date)
	ret0, _ := ret[0].(decimal.Decimal)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMultiplier indicates an expected call of GetMultiplier.
func (mr *MockCurrencyExchangerMockRecorder) GetMultiplier(ctx, currency, date interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMultiplier", reflect.TypeOf((*MockCurrencyExchanger)(nil).GetMultiplier), ctx, currency, date)
}

// MockCalculator is a mock of Calculator interface.
type MockCalculator struct {
	ctrl     *gomock.Controller
	recorder *MockCalculatorMockRecorder
}

// MockCalculatorMockRecorder is the mock recorder for MockCalculator.
type MockCalculatorMockRecorder struct {
	mock *MockCalculator
}

// NewMockCalculator creates a new mock instance.
func NewMockCalculator(ctrl *gomock.Controller) *MockCalculator {
	mock := &MockCalculator{ctrl: ctrl}
	mock.recorder = &MockCalculatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCalculator) EXPECT() *MockCalculatorMockRecorder {
	return m.recorder
}

// CalcByCurrentMonth mocks base method.
func (m *MockCalculator) CalcByCurrentMonth(ctx context.Context, userID int64, currency string) (map[string]decimal.Decimal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CalcByCurrentMonth", ctx, userID, currency)
	ret0, _ := ret[0].(map[string]decimal.Decimal)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CalcByCurrentMonth indicates an expected call of CalcByCurrentMonth.
func (mr *MockCalculatorMockRecorder) CalcByCurrentMonth(ctx, userID, currency interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalcByCurrentMonth", reflect.TypeOf((*MockCalculator)(nil).CalcByCurrentMonth), ctx, userID, currency)
}

// CalcByCurrentWeek mocks base method.
func (m *MockCalculator) CalcByCurrentWeek(ctx context.Context, userID int64, currency string) (map[string]decimal.Decimal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CalcByCurrentWeek", ctx, userID, currency)
	ret0, _ := ret[0].(map[string]decimal.Decimal)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CalcByCurrentWeek indicates an expected call of CalcByCurrentWeek.
func (mr *MockCalculatorMockRecorder) CalcByCurrentWeek(ctx, userID, currency interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalcByCurrentWeek", reflect.TypeOf((*MockCalculator)(nil).CalcByCurrentWeek), ctx, userID, currency)
}

// CalcByCurrentYear mocks base method.
func (m *MockCalculator) CalcByCurrentYear(ctx context.Context, userID int64, currency string) (map[string]decimal.Decimal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CalcByCurrentYear", ctx, userID, currency)
	ret0, _ := ret[0].(map[string]decimal.Decimal)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CalcByCurrentYear indicates an expected call of CalcByCurrentYear.
func (mr *MockCalculatorMockRecorder) CalcByCurrentYear(ctx, userID, currency interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalcByCurrentYear", reflect.TypeOf((*MockCalculator)(nil).CalcByCurrentYear), ctx, userID, currency)
}

// CalcSinceStartOfMonth mocks base method.
func (m *MockCalculator) CalcSinceStartOfMonth(ctx context.Context, userID int64, currency string, days int64) (map[string]decimal.Decimal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CalcSinceStartOfMonth", ctx, userID, currency, days)
	ret0, _ := ret[0].(map[string]decimal.Decimal)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CalcSinceStartOfMonth indicates an expected call of CalcSinceStartOfMonth.
func (mr *MockCalculatorMockRecorder) CalcSinceStartOfMonth(ctx, userID, currency, days interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalcSinceStartOfMonth", reflect.TypeOf((*MockCalculator)(nil).CalcSinceStartOfMonth), ctx, userID, currency, days)
}
